#ifndef _MEMT_Decoder_History_h
#define _MEMT_Decoder_History_h

#include "MEMT/Decoder/Score.hh"
#include "util/numbers.hh"
#include "util/debug.hh"

#include <boost/functional/hash.hpp>
#include <boost/iterator/iterator_adaptor.hpp>
#include <boost/iterator/iterator_facade.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/unordered/unordered_set.hpp>

#include <inttypes.h>

#include <vector>

namespace decoder {

struct HistoryEntry {
  struct LessByScore : public std::binary_function<const HistoryEntry &, const HistoryEntry &, bool> {
    bool operator()(const HistoryEntry &left, const HistoryEntry &right) const {
      return left.score < right.score;
    }
  };

  Score score;
  uint64_t word;
  unsigned int engine;
  unsigned int offset;

  // Score initialized separately.
  void InitializeRoot(uint64_t sentence_begin) {
    word = sentence_begin;
    // Without loss of generality, use the beginning of sentence from engine 0.
    engine = 0;
    offset = 0;
  }
};

/* A node in the lattice of histories generated by the decoder.
 * previous_ contains pointers to nodes with one less word in their history.
 * Entry().score has the highest score of a path from begin of sentence to here.
 *
 * Typical operation: 
 * Initialize a non-root node with SetPrevious and MutableEntry
 * Hand the node to the beam to find duplicates.
 * When the beam finds duplicates, it calls Merge.
 */
class HypHistory {
  public:
    // Return the cached hash value.  This hash covers all recursive packed histories back to beginning of sentence.
    struct ReturnHash : public std::unary_function<const boost::shared_ptr<HypHistory> &, size_t> {
      size_t operator()(const boost::shared_ptr<HypHistory> &hist) const {
        return hist->Hash();
      }
    };

    // Full HypHistory equality is really expensive: full tree comparison (possibly pruned by pointer equality).  
    // Instead I'm going to make the exceedingly likely assumption that there is no hash collision.
    struct EqualsHashOnly : public std::binary_function<const boost::shared_ptr<HypHistory> &, const boost::shared_ptr<HypHistory> &, bool> {
      bool operator()(const boost::shared_ptr<HypHistory> &left, const boost::shared_ptr<HypHistory> &right) const {
        return left->Hash() == right->Hash();
      }
    };

    typedef std::vector<boost::shared_ptr<HypHistory> > Previous;
    typedef Previous::const_iterator iterator;
    typedef Previous::const_iterator const_iterator;

    void InitializeRoot(uint64_t sentence_begin) {
      MutableEntry().InitializeRoot(sentence_begin);
      previous_.clear();
      DEBUG_ONLY(previous_valid_ = true);
      MakeHash();
    }

    void Reset() {
      previous_.clear();
      DEBUG_ONLY(hash_valid_ = false);
      DEBUG_ONLY(entry_valid_ = false);
      DEBUG_ONLY(previous_valid_ = false);
    }

    virtual ~HypHistory() {}

    // This can be accessed without invalidating the hash.
    Score &MutableScore() {
      return entry_.score;
    }

    // This is set by DecoderImpl and InternalHypothesis.
    HistoryEntry &MutableEntry() {
      DEBUG_ONLY(hash_valid_ = false);
      DEBUG_ONLY(entry_valid_ = true);
      return entry_;
    }

    // These are set by HistoryBeam.
    Previous &MutablePrevious() {
      DEBUG_ONLY(hash_valid_ = false);
      DEBUG_ONLY(previous_valid_ = true);
      return previous_;
    }
    // Direct beamless method for ending hypotheses.
    void SetSinglePrevious(const boost::shared_ptr<HypHistory> &to) {
      previous_.clear();
      previous_.push_back(to);
      DEBUG_ONLY(hash_valid_ = false);
      DEBUG_ONLY(previous_valid_ = true);
    }
    // Called by Hypothesis before inserting into beam.
    void MakeHash() {
      DEBUG_ONLY(assert(previous_valid_));
      hash_ = 0;
      boost::hash_combine(hash_, Entry().word);
      for (Previous::const_iterator i = previous_.begin(); i != previous_.end(); ++i) {
        boost::hash_combine(hash_, (*i)->Hash());
      }
      DEBUG_ONLY(hash_valid_ = true);
    }

    // Accessors

    // Precondition: MutableEntry used to put something sensible here
    const HistoryEntry &Entry() const {
      DEBUG_ONLY(assert(entry_valid_));
      return entry_;
    }

    /* Precondition for the remaining accessors:
     * DumpBeamToHypHistory called to place n-best list here.
     */
    // Highest scoring previous.
    const HypHistory *BestPrevious() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.empty() ? NULL : previous_.begin()->get();
    }
    
    //This can be any valid previous.  There are two different functions in case there's 
    // a cost to finding the best in a different implementation.
    // Returns NULL iff begin on sentence.
    const HypHistory *AnyPrevious() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.empty() ? NULL : previous_.begin()->get();
    }

    size_t Hash() const {
      DEBUG_ONLY(assert(hash_valid_));
      return hash_;
    }

    // Access to packed histories. 
    // Number of packed histories.  
    size_t size() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.size();
    }

    bool empty() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.empty();
    }

    // Iterate through packed histories in decreasing order of score.  This
    // does not go back to beginning of sentence.  
    const_iterator begin() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.begin();
    }

    const_iterator end() const {
      DEBUG_ONLY(assert(previous_valid_));
      return previous_.end();
    }

  protected:
    // Initialization
    HypHistory() {
      DEBUG_ONLY(hash_valid_ = false);
      DEBUG_ONLY(entry_valid_ = false);
    }

  private:
    DEBUG_ONLY(bool entry_valid_);
    HistoryEntry entry_;

    DEBUG_ONLY(bool previous_valid_);
    Previous previous_;

    DEBUG_ONLY(bool hash_valid_);
    size_t hash_;
};

/* There are two versions of HypHistory.  FastHypHistory ignores logging data. 
 * VerboseHypHistory remembers logging data so it can be used for analysis
 * later. */

class FastHypHistory : public HypHistory {
  public:
    FastHypHistory() {}
};

class VerboseHypHistory : public HypHistory {
  public:
    VerboseHypHistory() {}
};

} // namespace decoder

#endif
